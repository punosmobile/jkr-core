import pandas as pd
from pathlib import Path
import argparse
import base64
import os
import hashlib
import json
import sys
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# Lue Salasana ympäristömuuttujasta
DEFAULT_PASSW = os.getenv('PSEUDO_PASSW', 'default-passw-value-never-use-this-in-production')
DEFAULT_SALT = os.getenv('PSEUDO_SALT', 'default-salt-value-never-use-this-in-production')

def process_directory(dir_path: Path, cipher: Cipher, de_crypt: bool, output_suffix: str = None) -> None:
    """
    Recursively process all supported files in directory and its subdirectories.
    
    Args:
        dir_path: Path to directory to process
        cipher: Cipher to pass down for encryption and decryption
        de_crypt: Whether to encrypt or decrypt data
        output_suffix: text to add to the output filenames
    """
    try:
        # Recursively iterate through all files in directory and subdirectories
        for file_path in dir_path.rglob('*'):
            if file_path.is_file() and file_path.suffix.lower() in ['.xlsx', '.xls']:
                process_excel(file_path, cipher, de_crypt, output_suffix)
            else:
                print(f"{file_path} is not an excel file, skipping")
    except Exception as e:
        raise Exception(f"Error processing directory {dir_path}: {str(e)}")

def derive_key(password: str, salt: bytes) -> bytes:
    """
    generate key for encryption with given password and salt
    
    Args:
        password: Passphrase for encryption
        salt: List of bytes to use with the password
    """
    if  not isinstance(salt, bytes):
        salt = base64.b64decode(salt)

    if not isinstance(salt, bytes):
        salt = base64.b64decode(salt)
    return hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100_000)

backend = default_backend()

def get_cipher(key: bytes):
    """
    generate cipher for encryption with given key
    
    Args:
        key: generated by derive_key
    """
    iv = b'\x00' * 16  # 16 zero bytes - Static IV (not random)
    return Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)

def pseudonymize(value, cipher):
    """
    Pseudonymizes given value with given cipher
    
    Args:
        value: Value to Pseudonymize
        cipher: Cipher used to encrypt a value
    """
    if pd.isna(value):
        return value
        
    value_str = str(value)
    encryptor = cipher.encryptor()

    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(value_str.encode()) + padder.finalize()
    ct = encryptor.update(padded_data) + encryptor.finalize()
    return base64.urlsafe_b64encode(ct).decode()

def deanonymize(value: str, cipher: Cipher) -> str:
    """
    Deanonymizes given value with given cipher
    
    Args:
        value: Value to decrypt
        cipher: Cipher used to encrypt a value
    """
    decryptor = cipher.decryptor()
    plaintext = ""

    try:
        if not value or not isinstance(value, str) :
            return ""
        
        ct = base64.urlsafe_b64decode(value)

        padded_plaintext = decryptor.update(ct) + decryptor.finalize()
        unpadder = padding.PKCS7(128).unpadder()
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
    except Exception as e:
        print(value)
        raise e
    return plaintext.decode()

def process_sheet(df, fields_to_pseudonymize, cipher, de_crypt: bool = False):
    """
    Pseudonymisoi määritellyt kentät DataFrame:sta

    Args:
        df: Sheet to process
        fields_to_pseudonymize: Fields that should be encrypted/decrypted
        cipher: Cipher for encryption and decryption
        de_crypt: Should decrypt?
    """
    
    for field in fields_to_pseudonymize:
        print(f"kenttä: {field} columnit {df.columns}")
        print(f"Käsitellään kenttä: {field}")
        if de_crypt is False:
            df[field] = df[field].apply(lambda x: pseudonymize(x, cipher))
        else:
            df[field] = df[field].apply(lambda x: deanonymize(x, cipher))
    return df

def get_output_filename(input_file, output_suffix, de_crypt: bool = False):
    """
    Luo output-tiedoston nimen input-tiedoston ja output nimilisäyksen pohjalta

    Args:
        input_file: file that is being processed
        output_suffix: A string to add to the new filename
        de_crypt: Should decrypt?
    """
    output = output_suffix
    if output_suffix is None:
        if de_crypt is False:
            output = "_pseudottu"
        else:
            output = "_palautettu"

    input_path = Path(input_file)
    return str(input_path.parent / f"{input_path.stem}{output}{input_path.suffix}")

def process_excel(input_file: Path, cipher: Cipher, de_crypt: bool = False, output_file_suffix: str = None):
    """
    Lukee Excel-tiedoston ja pseudonymisoi määritellyt kentät kaikilta sheeteiltä, joista ne löytyvät
    
    Args:
        input_file: Polku syötetiedostoon
        passw: Salasana-arvo salaamiseen
        pseudo_fields: Sanakirja pseudonymisoitavista kentistä ja niiden maksimipituuksista
        output_file: Polku tulostiedostoon (valinnainen)
    """
    output_file = get_output_filename(input_file, output_file_suffix, de_crypt)

    # Lue kaikki sheetit
    print(f"Luetaan Excel-tiedostoa: {input_file}")
    all_sheets = pd.read_excel(input_file, sheet_name=None)
    
    processed_sheets = []
    # Käy läpi kaikki sheetit ja etsi pseudonymisoitavat kentät
    for sheet_name, df in all_sheets.items():
        # Tarkista löytyykö sheetistä pseudonymisoitavia kenttiä
        fields_in_sheet = {field
                            for field in pseudo_fields
                            if field in df.columns}
        
        if fields_in_sheet:
            print(f"\nKäsitellään sheet: {sheet_name}")
            print(f"Rivejä: {len(df)}")
            all_sheets[sheet_name] = process_sheet(df, fields_in_sheet, cipher, de_crypt)
            processed_sheets.append(sheet_name)

    # Tallenna kaikki sheetit
    print(f"\nTallennetaan pseudonymisoitu data tiedostoon: {output_file}")
    with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
        for sheet_name, df in all_sheets.items():
            df.to_excel(writer, sheet_name=sheet_name, index=False)
            
    print(f"Pseudonymisointi valmis!")
    if processed_sheets:
        print(f"Käsitellyt sheetit: {', '.join(processed_sheets)}")
    else:
        print("Huom: Yhtään pseudonymisoitavaa kenttää ei löytynyt mistään sheetistä!")
        

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Excel-tiedoston pseudonymisointi',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Esimerkkejä:
  python pseudonymisointi.py input.xlsx --pseudo_fields '["Henkilötunnus", "Y-tunnus"]' --salt b'6\xcc\xa7\x82\xbe\x8f/\xba\xa9/\x80\xb3\x8ey\xed\x87'
  python pseudonymisointi.py input.xlsx --pseudo_fields @fields.json --salt b'6\xcc\xa7\x82\xbe\x8f/\xba\xa9/\x80\xb3\x8ey\xed\x87'
  python pseudonymisointi.py input.xlsx --passw mypassw123 --pseudo_fields '["Nimi"]' --salt b'6\xcc\xa7\x82\xbe\x8f/\xba\xa9/\x80\xb3\x8ey\xed\x87'
  python pseudonymisointi.py input.xlsx -o _pseudonymisoitu -d=true --pseudo_fields '["Henkilötunnus"]'
        """
    )
    parser.add_argument('input_path', help='Syötetiedoston / kansion polku')
    parser.add_argument('--output_suffix', '-o', help='Tulostiedoston lisänimi (valinnainen)', default=None)
    parser.add_argument('--passw', '-p', help='Salasana-arvo pseudonymisointiin (valinnainen, oletuksena käyttää PSEUDO_PASSW ympäristömuuttujaa)', default=DEFAULT_PASSW)
    parser.add_argument('--salt', '-s', help='Suola-arvo, muodostaa salauksen salasanan kanssa', default=DEFAULT_SALT)
    parser.add_argument('--descrypt', '-d', help='Palautetaanko syöte', default=False)
    parser.add_argument('--pseudo_fields', required=True,
                      help='JSON-muotoinen sanakirja pseudonymisoitavista kentistä ja niiden maksimipituuksista. Voi olla joko suora JSON-merkkijono tai @-alkuinen tiedostopolku')

    args = parser.parse_args()

    # Käsittele pseudo_fields argumentti
    if args.pseudo_fields.startswith('@'):
        # Lue kentät JSON-tiedostosta
        with open(args.pseudo_fields[1:], 'r', encoding='utf-8') as f:
            pseudo_fields = json.load(f)
    else:
        # Parsitaan suoraan JSON-merkkijonosta
        pseudo_fields = json.loads(args.pseudo_fields)

    if not args.passw:
        parser.error("Salasana-arvoa ei ole määritetty! Käytä --passw argumenttia tai aseta PSEUDO_passw ympäristömuuttuja.")

    if not args.salt:
        parser.error("Suola-arvoa ei ole määritetty! Käytä --salt argumenttia.")

    de_crypt_init = False
    if (args.descrypt == "true"):
        print("decryptaus valittu")
        de_crypt_init = True

    path = Path(args.input_path)
    key = derive_key(args.passw, args.salt)
    base_cipher = get_cipher(key)
    
    # Process path based on whether it's a file or directory
    if path.is_file():
        # If it's an Excel file, process the _ripped version instead
        if path.suffix.lower() in ['.xlsx', '.xls']:
            
            if not args.output_suffix:
                print("tiedoston nimilisää ei ole määritetty. Käytä --output_file argumenttia määrittääksesi.")
                process_excel(path, base_cipher, de_crypt_init)
            else:
                process_excel(path, base_cipher, de_crypt_init, args.output_suffix)
        else:
            parser.error("Please supply a directory or excel file")
    elif path.is_dir():
        if not args.output_suffix:
            print("tiedoston nimilisää ei ole määritetty. Käytä --output_file argumenttia määrittääksesi sen manuaalisesti")
            process_directory(path, base_cipher, de_crypt_init)
        else:
            process_directory(path, base_cipher, de_crypt_init, args.output_suffix)
    else:
        print(f"Error: {path} is neither a file nor directory", file=sys.stderr)
        sys.exit(1)

    print("\nValmis!")