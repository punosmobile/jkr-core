from openpyxl import load_workbook
from pathlib import Path
import argparse
import base64
import os
import hashlib
import json
import sys
import csv
import shutil
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# Lue Salasana ympäristömuuttujasta
DEFAULT_PASSW = os.getenv('PSEUDO_PASSW', 'default-passw-value-never-use-this-in-production')
DEFAULT_SALT = os.getenv('PSEUDO_SALT', 'default-salt-value-never-use-this-in-production')

def process_directory(dir_path: Path, cipher: Cipher, pseudo_fields: set[str], de_crypt: bool, output_suffix: str = None) -> None:
    """
    Recursively process all supported files in directory and its subdirectories.
    
    Args:
        dir_path: Path to directory to process
        cipher: Cipher to pass down for encryption and decryption
        de_crypt: Whether to encrypt or decrypt data
        output_suffix: text to add to the output filenames
    """
    try:
        # Recursively iterate through all files in directory and subdirectories
        for file_path in dir_path.rglob('*'):
            if file_path.is_file() and file_path.suffix.lower() in ['.xlsx', '.xls']:
                process_excel(file_path, cipher, pseudo_fields, de_crypt, output_suffix)
            elif file_path.is_file() and file_path.suffix.lower() == '.csv':
                process_csv(file_path, cipher, pseudo_fields, de_crypt, output_suffix)
            else:
                print(f"{file_path} is not an excel or csv file, skipping")
    except Exception as e:
        raise Exception(f"Error processing directory {dir_path}: {str(e)}")

def derive_key(password: str, salt: bytes) -> bytes:
    """
    generate key for encryption with given password and salt
    
    Args:
        password: Passphrase for encryption
        salt: List of bytes to use with the password
    """
    if  not isinstance(salt, bytes):
        salt = base64.b64decode(salt)

    if not isinstance(salt, bytes):
        salt = base64.b64decode(salt)
    return hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100_000)

backend = default_backend()

def get_cipher(key: bytes):
    """
    generate cipher for encryption with given key
    
    Args:
        key: generated by derive_key
    """
    iv = b'\x00' * 16  # 16 zero bytes - Static IV (not random)
    return Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)

def pseudonymize(value, cipher):
    """
    Pseudonymizes given value with given cipher
    
    Args:
        value: Value to Pseudonymize
        cipher: Cipher used to encrypt a value
    """
    try:
        if value in (None, ''):
            return value

        value_str = str(value)
        encryptor = cipher.encryptor()

        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(value_str.encode()) + padder.finalize()
        ct = encryptor.update(padded_data) + encryptor.finalize()
        return base64.urlsafe_b64encode(ct).decode()
    except Exception as e:
        print(f"Kohdattiin virhe pseudonymisoinnissa: {e}")
        return ""

def depseudonymize(value: str, cipher: Cipher) -> str:
    """
    Depseudonymizes given value with given cipher
    
    Args:
        value: Value to decrypt
        cipher: Cipher used to encrypt a value
    """
    decryptor = cipher.decryptor()
    plaintext = ""

    try:
        if not value or not isinstance(value, str) :
            return ""
        
        ct = base64.urlsafe_b64decode(value)

        padded_plaintext = decryptor.update(ct) + decryptor.finalize()
        unpadder = padding.PKCS7(128).unpadder()
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
    except Exception as e:
        print(value)
        raise e
    return plaintext.decode()

def process_sheet(df, fields_to_pseudonymize, cipher, de_crypt: bool = False):
    """
    Pseudonymisoi määritellyt kentät DataFrame:sta

    Args:
        df: Sheet to process
        fields_to_pseudonymize: Fields that should be encrypted/decrypted
        cipher: Cipher for encryption and decryption
        de_crypt: Should decrypt?
    """
    
    for field in fields_to_pseudonymize:
        print(f"kenttä: {field} columnit {df.columns}")
        print(f"Käsitellään kenttä: {field}")
        if de_crypt is False:
            df[field] = df[field].apply(lambda x: pseudonymize(x, cipher))
        else:
            df[field] = df[field].apply(lambda x: depseudonymize(x, cipher))
    return df

def get_output_filename(input_file: Path, output_suffix, de_crypt: bool = False):
    """
    Luo output-tiedoston nimen input-tiedoston ja output nimilisäyksen pohjalta. 
    Palauttaa skip jos tiedoston nimessä on jo annettu output_suffix

    Args:
        input_file: file that is being processed
        output_suffix: A string to add to the new filename
        de_crypt: Should decrypt?
    """
    output = output_suffix
    if output_suffix is None:
        if de_crypt is False:
            output = "_pseudottu"
        else:
            output = "_palautettu"

    if output in str(input_file):
        return 'skip'

    input_path = Path(input_file)
    return str(input_path.parent / f"{input_path.stem}{output}{input_path.suffix}")

def process_excel(input_file: Path, cipher: Cipher, pseudo_fields: set[str], de_crypt: bool = False, output_file_suffix: str = None):
    """
    Lukee Excel-tiedoston ja pseudonymisoi määritellyt kentät kaikilta sheeteiltä, joista ne löytyvät.
    Säilyttää solujen muotoilut.
    
    Args:
        input_file: Polku syötetiedostoon
        cipher: Cipher salaukseen
        pseudo_fields: Sarakeotsikot, joita pseudonymisoidaan
        de_crypt: Jos True, suorittaa depseudonymisoinnin
        output_file_suffix: Tulostiedoston suffiksi
    """
    output_file = get_output_filename(input_file, output_file_suffix, de_crypt)

    if output_file == 'skip':
        print("Ohitetaan aiemmin käsitelty tiedosto.")
        return

    print(f"Luetaan Excel-tiedostoa: {input_file}")
    wb = load_workbook(filename=input_file)
    processed_sheets = []

    for ws in wb.worksheets:
        header_row = [cell.value for cell in ws[1]]
        target_columns = {
            i: header for i, header in enumerate(header_row)
            if header in pseudo_fields
        }

        if target_columns:
            print(f"\nKäsitellään sheet: {ws.title}")
            print(f"Rivejä: {ws.max_row - 1}")
            processed_sheets.append(ws.title)

            for row in ws.iter_rows(min_row=2, max_row=ws.max_row):
                for col_idx in target_columns:
                    cell = row[col_idx]
                    if cell.value is None:
                        continue
                    original = str(cell.value)
                    try:
                        cell.value = (
                            depseudonymize(original, cipher)
                            if de_crypt else
                            pseudonymize(original, cipher)
                        )
                    except Exception as e:
                        print(f"⚠️ Virhe solussa {ws.title} {cell.coordinate}: {e}")

    print(f"\nTallennetaan pseudonymisoitu data tiedostoon: {output_file}")
    wb.save(output_file)

    print("Pseudonymisointi valmis!")
    if processed_sheets:
        print(f"Käsitellyt sheetit: {', '.join(processed_sheets)}")
    else:
        print("Huom: Yhtään pseudonymisoitavaa kenttää ei löytynyt mistään sheetistä!")

def replace_with_new_files(path: Path, decrypt: bool = False, selected_suffix: str | None = None) -> None:
    """
    Recursively replace original files with their new versions.
    
    Args:
        path: Path to process
    """
    try:
        suffix = selected_suffix
        if suffix is None:
            if decrypt is False or decrypt is None:
                suffix = "_pseudottu."
            else:
                suffix = "_palautettu."
        else:
            suffix = suffix+'.'

        if path.is_file():
            if suffix in path.name:
                original_path = path.parent / path.name.replace(suffix, '.')
                if original_path.exists():
                    shutil.copy2(path, original_path)
                    path.unlink()
                    print(f"Replaced original file with processed version: {original_path}")
        elif path.is_dir():
            for processed_file in path.rglob('*'+suffix+'*'):
                original_path = processed_file.parent / processed_file.name.replace(suffix, '.')
                if original_path.exists():
                    shutil.copy2(processed_file, original_path)
                    processed_file.unlink()
                    print(f"Replaced original file with processed version: {original_path}")

    except Exception as e:
        print(f"Error while replacing files: {str(e)}", file=sys.stderr)

def process_csv(input_file: Path, cipher: Cipher, pseudo_fields: set[str], de_crypt: bool = False, output_file_suffix: str = None) -> None:
    """
    Process a CSV file, keeping only rows that contain at least one
    of the must_contain words (case insensitive). Preserves original lines exactly.
    Skip files that don't contain any of the words.
    
    Args:
        file_path: Path to the CSV file
        : Set of words that a row must contain at least one of
    """

    output_file = get_output_filename(input_file, output_file_suffix, de_crypt)

    if output_file == 'skip':
        print("Ohitetaan aiemmin käsitelty tiedosto.")
        return

    try:
        # Try different encodings in order
        encodings = ['utf-8', 'iso-8859-1', 'cp1252', 'latin1']
        content = None
        used_encoding = None

        for encoding in encodings:
            try:
                with open(input_file, 'r', encoding=encoding) as f:
                    content = f.readlines()
                used_encoding = encoding
                break
            except UnicodeDecodeError:
                continue

        print(f'\n\nencoding: {used_encoding}')
        if content is None:
            raise Exception("Failed to read file with any encoding")

        # Open source and output simultaneously, process each applicable column and save the results in a new file
        with open(input_file, newline='\n', encoding=used_encoding) as infile, \
             open(output_file, 'w', newline='\n', encoding=used_encoding) as outfile:

            reader = csv.DictReader(infile, delimiter=';')

            if reader.fieldnames is None:
                print(f"Ohitetaan tyhjä tiedosto: {input_file}")
                return

            writer = csv.DictWriter(outfile, fieldnames=reader.fieldnames,extrasaction='ignore', delimiter=';')
            writer.writeheader()

            print(f"\nKäsitellään tiedosto: {input_file}")

            rows = 0
            for row in reader:
                rows += 1
                for field in pseudo_fields:

                    if field in row.keys() and row[field] is not None:
                        unexpected = set(row) - set(reader.fieldnames)
                        if unexpected:
                            print(f"Warning: Extra fields found in row: {unexpected}")

                        if de_crypt is False:
                            row[field] = pseudonymize(row[field],cipher)
                        else:
                            row[field] = depseudonymize(row[field],cipher)

                writer.writerow(row)

            print(f"Rivejä: {rows}")

        print(f"Processed {output_file} using {used_encoding} encoding")

    except Exception as e:
        print(f"Error processing CSV {input_file}: {str(e)}", file=sys.stderr)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Excel-tiedoston pseudonymisointi',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Esimerkkejä:
  python pseudonymisointi.py input.xlsx --pseudo_fields '["Henkilötunnus", "Y-tunnus"]' --salt b'6\xcc\xa7\x82\xbe\x8f/\xba\xa9/\x80\xb3\x8ey\xed\x87'
  python pseudonymisointi.py input.xlsx --pseudo_fields @fields.json --salt b'6\xcc\xa7\x82\xbe\x8f/\xba\xa9/\x80\xb3\x8ey\xed\x87'
  python pseudonymisointi.py input.xlsx --passw mypassw123 --pseudo_fields '["Nimi"]' --salt b'6\xcc\xa7\x82\xbe\x8f/\xba\xa9/\x80\xb3\x8ey\xed\x87'
  python pseudonymisointi.py input.xlsx -o _pseudonymisoitu -d=true --pseudo_fields '["Henkilötunnus"]'
        """
    )
    parser.add_argument('input_path', help='Syötetiedoston / kansion polku')
    parser.add_argument('--output_suffix', '-o', help='Tulostiedoston lisänimi (valinnainen)', default=None)
    parser.add_argument('--passw', '-p', help='Salasana-arvo pseudonymisointiin (valinnainen, oletuksena käyttää PSEUDO_PASSW ympäristömuuttujaa)', default=DEFAULT_PASSW)
    parser.add_argument('--salt', '-s', help='Suola-arvo, muodostaa salauksen salasanan kanssa', default=DEFAULT_SALT)
    parser.add_argument('--decrypt', '-d', help='Palautetaanko syöte', default=False)
    parser.add_argument('--pseudo_fields', required=True,
                      help='JSON-muotoinen sanakirja pseudonymisoitavista kentistä ja niiden maksimipituuksista. Voi olla joko suora JSON-merkkijono tai @-alkuinen tiedostopolku')

    args = parser.parse_args()

    # Käsittele pseudo_fields argumentti
    if args.pseudo_fields.startswith('@'):
        # Lue kentät JSON-tiedostosta
        with open(args.pseudo_fields[1:], 'r', encoding='utf-8') as f:
            pseudo_fields = json.load(f)
    else:
        # Parsitaan suoraan JSON-merkkijonosta
        pseudo_fields = json.loads(args.pseudo_fields)

    if len(pseudo_fields) == 0:
        parser.error("Anna vähintään yksi käännettävä kenttä.")

    if not args.passw:
        parser.error("Salasana-arvoa ei ole määritetty! Käytä --passw argumenttia tai aseta PSEUDO_passw ympäristömuuttuja.")

    if not args.salt:
        parser.error("Suola-arvoa ei ole määritetty! Käytä --salt argumenttia.")

    de_crypt_init = False
    if args.decrypt == "true":
        print("decryptaus valittu")
        de_crypt_init = True

    path = Path(args.input_path)
    key = derive_key(args.passw, args.salt)
    base_cipher = get_cipher(key)

    # Process path based on whether it's a file or directory
    if path.is_file():
        # If it's an Excel file, process the _new version instead
        if path.suffix.lower() in ['.xlsx', '.xls']:

            if not args.output_suffix:
                print("HUOM! tiedoston nimilisää ei ole määritetty. Käytä --output_file argumenttia määrittääksesi.")
                process_excel(path, base_cipher, pseudo_fields, de_crypt_init)
            else:
                process_excel(path, base_cipher, pseudo_fields, de_crypt_init, args.output_suffix)
        elif path.suffix.lower() == '.csv':
            if not args.output_suffix:
                print("HUOM! tiedoston nimilisää ei ole määritetty. Käytä --output_file argumenttia määrittääksesi.")
                print("Käytetään oletusarvoa _pseudottu/_palautettu.")
                process_csv(path, base_cipher, pseudo_fields, de_crypt_init)
            else:
                process_csv(path, base_cipher, pseudo_fields, de_crypt_init, args.output_suffix)
        else:
            parser.error("Please supply a directory, excel or csv file")
    elif path.is_dir():
        if not args.output_suffix:
            print("tiedoston nimilisää ei ole määritetty. Käytä --output_file argumenttia määrittääksesi sen manuaalisesti")
            print("Käytetään oletusarvoa _pseudottu/_palautettu.")
            process_directory(path, base_cipher, pseudo_fields, de_crypt_init)
        else:
            process_directory(path, base_cipher, pseudo_fields, de_crypt_init, args.output_suffix)
    else:
        print(f"Error: {path} is neither a file nor directory", file=sys.stderr)
        sys.exit(1)

     # Ask user if they want to replace original files
    while True:
        response = input("\nKorvataanko alkuperäiset tiedostot uusilla-versioilla? (Y/N): ").strip().upper()
        if response in ['Y', 'N']:
            break
        print("Virheellinen vastaus. Anna Y (Kyllä) tai N (Ei).")

    if response == 'Y':
        print("\nKorvataan alkuperäiset tiedostot uusilla-versioilla...")
        replace_with_new_files(path, args.output_suffix)
        print("Korvaus valmis!")

    print("\nValmis!")